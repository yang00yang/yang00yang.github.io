{"meta":{"title":"杨亨的博客","subtitle":null,"description":"一个刚毕业的小程序员","author":"杨亨","url":"http://yoursite.com"},"pages":[{"title":"","date":"un44fin44","updated":"un44fin44","comments":true,"path":"gost/index.html","permalink":"http://yoursite.com/gost/index.html","excerpt":"","text":"��CSS3�������¸���������Ч - A5Դ�� *{padding:0;margin:0;} body{ position:relative; background:#90C0F1; overflow:hidden; } .ghost{ width:160px; margin:100px auto; position:relative; animation:ghostUpdown 1s infinite alternate; -webkit-animation:ghostUpdown 1s infinite alternate; } .ghostBody{ width:140px; height:180px; background:#fff; border-radius:100% 100% 0 0; position:relative; } .ghostEye{ width:15px; height:20px; border-radius:100%; border:2px solid #061E74; background:#061E74; box-shadow:inset -2px -2px #fff; position:absolute; top:60px; } .left{left:45px} .right{right:50px;} .ghostMouth{ width:15px; height:20px; border-radius:100%; border:2px solid #061E74; position:absolute; top:90px; left:70px; } .ghostWave{ position:absolute; width: 140px; height: 20px; background-size:25px 20px; background-image:radial-gradient(circle at 50% 0%,#fff,71%,transparent 71%); } .shadow{ width:140px; height:10px; border-radius:100%; background:#061E74; opacity:0.3; margin-top:70px; animation:shadow 1s infinite alternate; -webkit-animation:shadow 1s infinite alternate; } @keyframes ghostUpdown{ from{margin-top:100px;} to{margin-top:70px;} } @-webkit-keyframes ghostUpdown{ from{margin-top:100px;} to{margin-top:70px;} } @keyframes shadow{ from{margin-top:70px;opacity:0.3;} to{margin-top:100px;opacity:0.1;} } @-webkit-keyframes shadow{ from{margin-top:70px;opacity:0.3;} to{margin-top:100px;opacity:0.1;} } 飘飘飘飘飘 飘飘飘飘飘","raw":"---\nlayout: false\n---\n<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"gb2312\">\n  <title>��CSS3�������¸���������Ч - A5Դ��</title>\n  <style>\n  *{padding:0;margin:0;}\n\tbody{\n\t\tposition:relative;\n   \t    background:#90C0F1;\n\t    overflow:hidden;\n\t}\n\t.ghost{\n\t\twidth:160px;\n\t\tmargin:100px auto;\n\t\tposition:relative;\n\t\tanimation:ghostUpdown 1s infinite alternate;\n\t\t-webkit-animation:ghostUpdown 1s infinite alternate;\n\t}\n\t.ghostBody{\n\t\twidth:140px;\n\t\theight:180px;\n\t\tbackground:#fff;\n\t\tborder-radius:100% 100% 0 0;\n\t\tposition:relative;\n\t}\n\t.ghostEye{\n\t\twidth:15px;\n\t\theight:20px;\n\t\tborder-radius:100%;\n\t\tborder:2px solid #061E74;\n\t\tbackground:#061E74;\n\t\tbox-shadow:inset -2px -2px #fff;\n\t\tposition:absolute;\n\t\ttop:60px;\n\t}\n\t.left{left:45px}\n\t.right{right:50px;}\n\t.ghostMouth{\n\t\twidth:15px;\n\t\theight:20px;\n\t\tborder-radius:100%;\n\t\tborder:2px solid #061E74;\n\t\tposition:absolute;\n\t\ttop:90px;\n\t\tleft:70px;\n\t}\n\t.ghostWave{\n\t\tposition:absolute;\n\t\twidth: 140px;\n\t\theight: 20px;\n\t\tbackground-size:25px 20px;\n\t\tbackground-image:radial-gradient(circle at 50% 0%,#fff,71%,transparent 71%);\n\t}\n\t.shadow{\n\t\twidth:140px;\n\t\theight:10px;\n\t\tborder-radius:100%;\n\t\tbackground:#061E74;\n\t\topacity:0.3;\n\t\tmargin-top:70px;\n\t\tanimation:shadow 1s infinite alternate;\n\t\t-webkit-animation:shadow 1s infinite alternate;\n\t}\n\t@keyframes ghostUpdown{\n\t\tfrom{margin-top:100px;}\n\t\tto{margin-top:70px;}\n\t}\n\t@-webkit-keyframes ghostUpdown{\n\t\tfrom{margin-top:100px;}\n\t\tto{margin-top:70px;}\n\t}\n\t@keyframes shadow{\n\t\tfrom{margin-top:70px;opacity:0.3;}\n\t\tto{margin-top:100px;opacity:0.1;}\n\t}\n\t@-webkit-keyframes shadow{\n\t\tfrom{margin-top:70px;opacity:0.3;}\n\t\tto{margin-top:100px;opacity:0.1;}\n\t}\n  </style>\n </head>\n <body>\n\t<div class=\"ghost\">\n\t\t<div class=\"ghostBody\"></div>\n\t\t<div class=\"ghostEye left\"></div>\n\t\t<div class=\"ghostEye right\"></div>\n\t\t<div class=\"ghostMouth\"></div>\n\t\t<div class=\"ghostWave\"></div>\n\t\t<div class=\"shadow\"></div>\n\t</div>\n\n<div style=\"text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';\">\n<p>飘飘飘飘飘</p>\n<p>飘飘飘飘飘</p>\n</div>\n</body>\n</html>\n","content":"<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"gb2312\">\n  <title>��CSS3�������¸���������Ч - A5Դ��</title>\n  <style>\n  *{padding:0;margin:0;}\n\tbody{\n\t\tposition:relative;\n   \t    background:#90C0F1;\n\t    overflow:hidden;\n\t}\n\t.ghost{\n\t\twidth:160px;\n\t\tmargin:100px auto;\n\t\tposition:relative;\n\t\tanimation:ghostUpdown 1s infinite alternate;\n\t\t-webkit-animation:ghostUpdown 1s infinite alternate;\n\t}\n\t.ghostBody{\n\t\twidth:140px;\n\t\theight:180px;\n\t\tbackground:#fff;\n\t\tborder-radius:100% 100% 0 0;\n\t\tposition:relative;\n\t}\n\t.ghostEye{\n\t\twidth:15px;\n\t\theight:20px;\n\t\tborder-radius:100%;\n\t\tborder:2px solid #061E74;\n\t\tbackground:#061E74;\n\t\tbox-shadow:inset -2px -2px #fff;\n\t\tposition:absolute;\n\t\ttop:60px;\n\t}\n\t.left{left:45px}\n\t.right{right:50px;}\n\t.ghostMouth{\n\t\twidth:15px;\n\t\theight:20px;\n\t\tborder-radius:100%;\n\t\tborder:2px solid #061E74;\n\t\tposition:absolute;\n\t\ttop:90px;\n\t\tleft:70px;\n\t}\n\t.ghostWave{\n\t\tposition:absolute;\n\t\twidth: 140px;\n\t\theight: 20px;\n\t\tbackground-size:25px 20px;\n\t\tbackground-image:radial-gradient(circle at 50% 0%,#fff,71%,transparent 71%);\n\t}\n\t.shadow{\n\t\twidth:140px;\n\t\theight:10px;\n\t\tborder-radius:100%;\n\t\tbackground:#061E74;\n\t\topacity:0.3;\n\t\tmargin-top:70px;\n\t\tanimation:shadow 1s infinite alternate;\n\t\t-webkit-animation:shadow 1s infinite alternate;\n\t}\n\t@keyframes ghostUpdown{\n\t\tfrom{margin-top:100px;}\n\t\tto{margin-top:70px;}\n\t}\n\t@-webkit-keyframes ghostUpdown{\n\t\tfrom{margin-top:100px;}\n\t\tto{margin-top:70px;}\n\t}\n\t@keyframes shadow{\n\t\tfrom{margin-top:70px;opacity:0.3;}\n\t\tto{margin-top:100px;opacity:0.1;}\n\t}\n\t@-webkit-keyframes shadow{\n\t\tfrom{margin-top:70px;opacity:0.3;}\n\t\tto{margin-top:100px;opacity:0.1;}\n\t}\n  </style>\n </head>\n <body>\n\t<div class=\"ghost\">\n\t\t<div class=\"ghostBody\"></div>\n\t\t<div class=\"ghostEye left\"></div>\n\t\t<div class=\"ghostEye right\"></div>\n\t\t<div class=\"ghostMouth\"></div>\n\t\t<div class=\"ghostWave\"></div>\n\t\t<div class=\"shadow\"></div>\n\t</div>\n\n<div style=\"text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';\">\n<p>飘飘飘飘飘</p>\n<p>飘飘飘飘飘</p>\n</div>\n</body>\n</html>\n"}],"posts":[{"title":"Java并发编程：volatile关键字解析","slug":"并发编程","date":"un11fin11","updated":"un66fin66","comments":true,"path":"2018/01/01/并发编程/","link":"","permalink":"http://yoursite.com/2018/01/01/并发编程/","excerpt":"","text":"Java并发编程：volatile关键字解析volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。 volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。 以下是本文的目录大纲： 一.内存模型的相关概念 二.并发编程中的三个概念 三.Java内存模型 四..深入剖析volatile关键字 五.使用volatile关键字的场景 一.内存模型的相关概念大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 1）通过在总线加LOCK#锁的方式 2）通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 二.并发编程中的三个概念在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 1.原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 2.可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： //线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.有序性有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： int i = 0; boolean flag = false; i = 1;//语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： int a = 10;//语句1 int r = 2;//语句2 a = a + 3;//语句3 r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context);上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 三.Java内存模型在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 1.原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： x = 10; //语句1 y = x; //语句2 x++; //语句3 x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 2.可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 3.有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始这8条原则摘自《深入理解Java虚拟机》。 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 四.深入剖析volatile关键字在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 1.volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： //线程1 boolean stop = false; while(!stop){ doSomething(); } //线程2 stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2.volatile保证原子性吗？ 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： public class Test { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } } 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： public class Test { public int inc = 0; public synchronized void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } } 采用Lock： public class Test { public int inc = 0; Lock lock = new ReentrantLock(); public void increase() { lock.lock(); try { inc++; } finally{ lock.unlock(); } } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } } 采用AtomicInteger： public class Test { public AtomicInteger inc = new AtomicInteger(); public void increase() { inc.getAndIncrement(); } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } } 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile能保证有序性吗？ 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： //x、y为非volatile变量 //flag为volatile变量 x = 2;//语句1 y = 0;//语句2 flag = true; //语句3 x = 4; //语句4 y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context);前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 4.volatile的原理和实现机制 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 五.使用volatile关键字的场景 synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 1.状态标记量 volatile boolean flag = false; while(!flag){ doSomething(); } public void setFlag() { flag = true; } volatile boolean inited = false; //线程1: context = loadContext(); inited = true; //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context); 2.double check class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 至于为何需要这么写请参考： 《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024 和http://www.iteye.com/topic/652440 参考资料： 《Java编程思想》 《深入理解Java虚拟机》 http://jiangzhengjun.iteye.com/blog/652532 http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html http://ifeve.com/volatile/ http://blog.csdn.net/ccit0519/article/details/11241403 http://blog.csdn.net/ns_code/article/details/17101369 http://www.cppblog.com/elva/archive/2011/01/21/139019.html http://www.bdqn.cn/news/201312/12579.shtml http://exploer.blog.51cto.com/7123589/1193399 http://www.cnblogs.com/Mainz/p/3556430.html","raw":"---\ntitle: Java并发编程：volatile关键字解析\ndate: 2018-01-01\ncategories: First\nauthor: 杨亨\ncover_picture: /images/并发.jpg\ntags:\n    - 技术\n    - blog\n---\n#     Java并发编程：volatile关键字解析  #\n\nvolatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。\n\nvolatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。\n\n以下是本文的目录大纲：\n\n一.内存模型的相关概念\n\n二.并发编程中的三个概念\n\n三.Java内存模型\n\n四..深入剖析volatile关键字\n\n五.使用volatile关键字的场景\n\n\n# 一.内存模型的相关概念 #\n\n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n\n![](https://i.imgur.com/PnfxAV5.jpg)\n\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\n\n\n    i = i + 1;\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n\n这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n\n为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n\n1）通过在总线加LOCK#锁的方式\n\n2）通过缓存一致性协议\n\n这2种方式都是硬件层面上提供的方式。\n\n在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n\n\n# 二.并发编程中的三个概念 #\n\n在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：\n\n## 1.原子性 ##\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n    i = 9;\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n## 2.可见性 ##\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n举个简单的例子，看下面这段代码：\n\n    //线程1执行的代码\n    int i = 0;\n    i = 10;\n     \n    //线程2执行的代码\n    j = i;\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n## 3.有序性 ##\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n    \n    int i = 0;  \n    boolean flag = false;\n    i = 1;//语句1  \n    flag = true;  //语句2\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n    \n    int a = 10;//语句1\n    int r = 2;//语句2\n    a = a + 3;//语句3\n    r = a*a; //语句4\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n\n\n那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3\n\n不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n\n虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n\n    //线程1:\n    context = loadContext();   //语句1\n    inited = true; //语句2\n     \n    //线程2:\n    while(!inited ){\n      sleep()\n    }\ndoSomethingwithconfig(context);\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n# 三.Java内存模型 #\n\n在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。\n\n在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n\n    i  = 10;\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\n\n## 1.原子性 ##\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n\n    x = 10; //语句1\n    y = x; //语句2\n    x++;   //语句3\n    x = x + 1; //语句4\n咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n## 2.可见性 ##\n\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n## 3.有序性 ##\n\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\nvolatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n这8条原则摘自《深入理解Java虚拟机》。\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n# 四.深入剖析volatile关键字 #\n\n在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。\n\n## 1.volatile关键字的两层语义 ##\n\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n2）禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n    \n    //线程1\n    boolean stop = false;\n    while(!stop){\n    doSomething();\n    }\n     \n    //线程2\n    stop = true;\n\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n第一：使用volatile关键字会强制将修改的值立即写入主存；\n\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2.volatile保证原子性吗？\n\n从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n\n下面看一个例子：\n\n\n    public class Test {\n    public volatile int inc = 0;\n     \n    public void increase() {\n    inc++;\n    }\n     \n    public static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i<10;i++){\n    new Thread(){\n    public void run() {\n    for(int j=0;j<1000;j++)\n    test.increase();\n    };\n    }.start();\n    }\n     \n    while(Thread.activeCount()>1)  //保证前面的线程都执行完\n    Thread.yield();\n    System.out.println(test.inc);\n    }\n    }\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n采用synchronized：\n\n\n    public class Test {\n    public  int inc = 0;\n     \n    public synchronized void increase() {\n    inc++;\n    }\n     \n    public static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i<10;i++){\n    new Thread(){\n    public void run() {\n    for(int j=0;j<1000;j++)\n    test.increase();\n    };\n    }.start();\n    }\n     \n    while(Thread.activeCount()>1)  //保证前面的线程都执行完\n    Thread.yield();\n    System.out.println(test.inc);\n    }\n    }\n采用Lock：\n\n    \n    public class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n     \n    public  void increase() {\n    lock.lock();\n    try {\n    inc++;\n    } finally{\n    lock.unlock();\n    }\n    }\n     \n    public static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i<10;i++){\n    new Thread(){\n    public void run() {\n    for(int j=0;j<1000;j++)\n    test.increase();\n    };\n    }.start();\n    }\n     \n    while(Thread.activeCount()>1)  //保证前面的线程都执行完\n    Thread.yield();\n    System.out.println(test.inc);\n    }\n    }\n采用AtomicInteger：\n\n    public class Test {\n    public  AtomicInteger inc = new AtomicInteger();\n     \n    public  void increase() {\n    inc.getAndIncrement();\n    }\n     \n    public static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i<10;i++){\n    new Thread(){\n    public void run() {\n    for(int j=0;j<1000;j++)\n    test.increase();\n    };\n    }.start();\n    }\n     \n    while(Thread.activeCount()>1)  //保证前面的线程都执行完\n    Thread.yield();\n    System.out.println(test.inc);\n    }\n    }\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3.volatile能保证有序性吗？\n\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n\n    //x、y为非volatile变量\n    //flag为volatile变量\n     \n    x = 2;//语句1\n    y = 0;//语句2\n    flag = true;  //语句3\n    x = 4; //语句4\n    y = -1;   //语句5\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\n\n并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。\n\n那么我们回到前面举的一个例子：\n\n\n    //线程1:\n    context = loadContext();   //语句1\n    inited = true; //语句2\n     \n    //线程2:\n    while(!inited ){\n      sleep()\n    }\ndoSomethingwithconfig(context);\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n4.volatile的原理和实现机制\n\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n下面这段话摘自《深入理解Java虚拟机》：\n\n“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n\n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n\n2）它会强制将对缓存的修改操作立即写入主存；\n\n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n五.使用volatile关键字的场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n1）对变量的写操作不依赖于当前值\n\n2）该变量没有包含在具有其他变量的不变式中\n\n实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n\n事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n\n下面列举几个Java中使用volatile的几个场景。\n\n1.状态标记量\n\n    volatile boolean flag = false;\n     \n    while(!flag){\n    doSomething();\n    }\n     \n    public void setFlag() {\n    flag = true;\n    }\n\n    volatile boolean inited = false;\n    //线程1:\n    context = loadContext();  \n    inited = true;\n     \n    //线程2:\n    while(!inited ){\n    sleep()\n    }\n    doSomethingwithconfig(context);\n     \n\n2.double check\n\n    \n    class Singleton{\n    private volatile static Singleton instance = null;\n     \n    private Singleton() {\n     \n    }\n     \n    public static Singleton getInstance() {\n    if(instance==null) {\n    synchronized (Singleton.class) {\n    if(instance==null)\n    instance = new Singleton();\n    }\n    }\n    return instance;\n    }\n    }\n至于为何需要这么写请参考：\n\n《Java 中的双重检查（Double-Check）》\n[http://blog.csdn.net/dl88250/article/details/5439024](http://blog.csdn.net/dl88250/article/details/5439024)\n\n和[http://www.iteye.com/topic/652440](http://www.iteye.com/topic/652440)\n\n参考资料：\n\n《Java编程思想》\n\n《深入理解Java虚拟机》\n\n[http://jiangzhengjun.iteye.com/blog/652532](http://jiangzhengjun.iteye.com/blog/652532)\n\n[http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html](http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html)\n\n[http://ifeve.com/volatile/](http://ifeve.com/volatile/)\n\n[http://blog.csdn.net/ccit0519/article/details/11241403](http://blog.csdn.net/ccit0519/article/details/11241403)\n\n[http://blog.csdn.net/ns_code/article/details/17101369](http://blog.csdn.net/ns_code/article/details/17101369)\n\n[http://www.cppblog.com/elva/archive/2011/01/21/139019.html](http://www.cppblog.com/elva/archive/2011/01/21/139019.html)\n\n\n[http://www.bdqn.cn/news/201312/12579.shtml](http://www.bdqn.cn/news/201312/12579.shtml)\n\n[http://exploer.blog.51cto.com/7123589/1193399](http://exploer.blog.51cto.com/7123589/1193399)\n\n[http://www.cnblogs.com/Mainz/p/3556430.html](http://www.cnblogs.com/Mainz/p/3556430.html)","content":"<h1 id=\"Java并发编程：volatile关键字解析\"><a href=\"#Java并发编程：volatile关键字解析\" class=\"headerlink\" title=\"Java并发编程：volatile关键字解析\"></a>Java并发编程：volatile关键字解析</h1><p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>\n<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>\n<p>以下是本文的目录大纲：</p>\n<p>一.内存模型的相关概念</p>\n<p>二.并发编程中的三个概念</p>\n<p>三.Java内存模型</p>\n<p>四..深入剖析volatile关键字</p>\n<p>五.使用volatile关键字的场景</p>\n<h1 id=\"一-内存模型的相关概念\"><a href=\"#一-内存模型的相关概念\" class=\"headerlink\" title=\"一.内存模型的相关概念\"></a>一.内存模型的相关概念</h1><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>\n<p><img src=\"https://i.imgur.com/PnfxAV5.jpg\" alt=\"\"></p>\n<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>\n<pre><code>i = i + 1;\n</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>\n<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>\n<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>\n<p>1）通过在总线加LOCK#锁的方式</p>\n<p>2）通过缓存一致性协议</p>\n<p>这2种方式都是硬件层面上提供的方式。</p>\n<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>\n<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>\n<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<h1 id=\"二-并发编程中的三个概念\"><a href=\"#二-并发编程中的三个概念\" class=\"headerlink\" title=\"二.并发编程中的三个概念\"></a>二.并发编程中的三个概念</h1><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>\n<h2 id=\"1-原子性\"><a href=\"#1-原子性\" class=\"headerlink\" title=\"1.原子性\"></a>1.原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<pre><code>i = 9;\n</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<h2 id=\"2-可见性\"><a href=\"#2-可见性\" class=\"headerlink\" title=\"2.可见性\"></a>2.可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>举个简单的例子，看下面这段代码：</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n\n//线程2执行的代码\nj = i;\n</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<h2 id=\"3-有序性\"><a href=\"#3-有序性\" class=\"headerlink\" title=\"3.有序性\"></a>3.有序性</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>\n<pre><code>int i = 0;  \nboolean flag = false;\ni = 1;//语句1  \nflag = true;  //语句2\n</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<pre><code>int a = 10;//语句1\nint r = 2;//语句2\na = a + 3;//语句3\nr = a*a; //语句4\n</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>\n<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<pre><code>//线程1:\ncontext = loadContext();   //语句1\ninited = true; //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\n</code></pre><p>doSomethingwithconfig(context);<br>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<h1 id=\"三-Java内存模型\"><a href=\"#三-Java内存模型\" class=\"headerlink\" title=\"三.Java内存模型\"></a>三.Java内存模型</h1><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>\n<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<pre><code>i  = 10;\n</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>\n<h2 id=\"1-原子性-1\"><a href=\"#1-原子性-1\" class=\"headerlink\" title=\"1.原子性\"></a>1.原子性</h2><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<pre><code>x = 10; //语句1\ny = x; //语句2\nx++;   //语句3\nx = x + 1; //语句4\n</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<h2 id=\"2-可见性-1\"><a href=\"#2-可见性-1\" class=\"headerlink\" title=\"2.可见性\"></a>2.可见性</h2><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<h2 id=\"3-有序性-1\"><a href=\"#3-有序性-1\" class=\"headerlink\" title=\"3.有序性\"></a>3.有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<h1 id=\"四-深入剖析volatile关键字\"><a href=\"#四-深入剖析volatile关键字\" class=\"headerlink\" title=\"四.深入剖析volatile关键字\"></a>四.深入剖析volatile关键字</h1><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>\n<h2 id=\"1-volatile关键字的两层语义\"><a href=\"#1-volatile关键字的两层语义\" class=\"headerlink\" title=\"1.volatile关键字的两层语义\"></a>1.volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n<p>2）禁止进行指令重排序。</p>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<pre><code>//线程1\nboolean stop = false;\nwhile(!stop){\ndoSomething();\n}\n\n//线程2\nstop = true;\n</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>\n<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<p>2.volatile保证原子性吗？</p>\n<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>\n<p>下面看一个例子：</p>\n<pre><code>public class Test {\npublic volatile int inc = 0;\n\npublic void increase() {\ninc++;\n}\n\npublic static void main(String[] args) {\nfinal Test test = new Test();\nfor(int i=0;i&lt;10;i++){\nnew Thread(){\npublic void run() {\nfor(int j=0;j&lt;1000;j++)\ntest.increase();\n};\n}.start();\n}\n\nwhile(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\nThread.yield();\nSystem.out.println(test.inc);\n}\n}\n</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>把上面的代码改成以下任何一种都可以达到效果：</p>\n<p>采用synchronized：</p>\n<pre><code>public class Test {\npublic  int inc = 0;\n\npublic synchronized void increase() {\ninc++;\n}\n\npublic static void main(String[] args) {\nfinal Test test = new Test();\nfor(int i=0;i&lt;10;i++){\nnew Thread(){\npublic void run() {\nfor(int j=0;j&lt;1000;j++)\ntest.increase();\n};\n}.start();\n}\n\nwhile(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\nThread.yield();\nSystem.out.println(test.inc);\n}\n}\n</code></pre><p>采用Lock：</p>\n<pre><code>public class Test {\npublic  int inc = 0;\nLock lock = new ReentrantLock();\n\npublic  void increase() {\nlock.lock();\ntry {\ninc++;\n} finally{\nlock.unlock();\n}\n}\n\npublic static void main(String[] args) {\nfinal Test test = new Test();\nfor(int i=0;i&lt;10;i++){\nnew Thread(){\npublic void run() {\nfor(int j=0;j&lt;1000;j++)\ntest.increase();\n};\n}.start();\n}\n\nwhile(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\nThread.yield();\nSystem.out.println(test.inc);\n}\n}\n</code></pre><p>采用AtomicInteger：</p>\n<pre><code>public class Test {\npublic  AtomicInteger inc = new AtomicInteger();\n\npublic  void increase() {\ninc.getAndIncrement();\n}\n\npublic static void main(String[] args) {\nfinal Test test = new Test();\nfor(int i=0;i&lt;10;i++){\nnew Thread(){\npublic void run() {\nfor(int j=0;j&lt;1000;j++)\ntest.increase();\n};\n}.start();\n}\n\nwhile(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\nThread.yield();\nSystem.out.println(test.inc);\n}\n}\n</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<p>3.volatile能保证有序性吗？</p>\n<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<pre><code>//x、y为非volatile变量\n//flag为volatile变量\n\nx = 2;//语句1\ny = 0;//语句2\nflag = true;  //语句3\nx = 4; //语句4\ny = -1;   //语句5\n</code></pre><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>\n<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>\n<p>那么我们回到前面举的一个例子：</p>\n<pre><code>//线程1:\ncontext = loadContext();   //语句1\ninited = true; //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\n</code></pre><p>doSomethingwithconfig(context);<br>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<p>4.volatile的原理和实现机制</p>\n<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>\n<p>下面这段话摘自《深入理解Java虚拟机》：</p>\n<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>\n<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>\n<p>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>\n<p>2）它会强制将对缓存的修改操作立即写入主存；</p>\n<p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>\n<p>五.使用volatile关键字的场景</p>\n<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<p>1）对变量的写操作不依赖于当前值</p>\n<p>2）该变量没有包含在具有其他变量的不变式中</p>\n<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>\n<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<p>1.状态标记量</p>\n<pre><code>volatile boolean flag = false;\n\nwhile(!flag){\ndoSomething();\n}\n\npublic void setFlag() {\nflag = true;\n}\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;\n\n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n</code></pre><p>2.double check</p>\n<pre><code>class Singleton{\nprivate volatile static Singleton instance = null;\n\nprivate Singleton() {\n\n}\n\npublic static Singleton getInstance() {\nif(instance==null) {\nsynchronized (Singleton.class) {\nif(instance==null)\ninstance = new Singleton();\n}\n}\nreturn instance;\n}\n}\n</code></pre><p>至于为何需要这么写请参考：</p>\n<p>《Java 中的双重检查（Double-Check）》<br><a href=\"http://blog.csdn.net/dl88250/article/details/5439024\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dl88250/article/details/5439024</a></p>\n<p>和<a href=\"http://www.iteye.com/topic/652440\" target=\"_blank\" rel=\"external\">http://www.iteye.com/topic/652440</a></p>\n<p>参考资料：</p>\n<p>《Java编程思想》</p>\n<p>《深入理解Java虚拟机》</p>\n<p><a href=\"http://jiangzhengjun.iteye.com/blog/652532\" target=\"_blank\" rel=\"external\">http://jiangzhengjun.iteye.com/blog/652532</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>\n<p><a href=\"http://ifeve.com/volatile/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile/</a></p>\n<p><a href=\"http://blog.csdn.net/ccit0519/article/details/11241403\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>\n<p><a href=\"http://blog.csdn.net/ns_code/article/details/17101369\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ns_code/article/details/17101369</a></p>\n<p><a href=\"http://www.cppblog.com/elva/archive/2011/01/21/139019.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>\n<p><a href=\"http://www.bdqn.cn/news/201312/12579.shtml\" target=\"_blank\" rel=\"external\">http://www.bdqn.cn/news/201312/12579.shtml</a></p>\n<p><a href=\"http://exploer.blog.51cto.com/7123589/1193399\" target=\"_blank\" rel=\"external\">http://exploer.blog.51cto.com/7123589/1193399</a></p>\n<p><a href=\"http://www.cnblogs.com/Mainz/p/3556430.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>\n","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"代理服务器、反向代理服务器以及Nginx","slug":"nginx","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/09/21/nginx/","link":"","permalink":"http://yoursite.com/2017/09/21/nginx/","excerpt":"","text":"最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别代理服务器通常分为两种转发代理(forward proxy)服务器和反向代理(reverse proxy)服务器 1） 转发代理服务器转发代理服务器平常简称为代理服务器 普通的转发代理服务器是客户端与原始服务器之间的一个中间服务器。 为了从原始服务器获取内容，客户端发送请求到代理服务器，然后代理服务器从原始服务器中获取内容再返回给客户端。客户端必须专门地配置转发代理来访问其他站点，如在浏览器中配置代理服务器地址及端口号等。 转发代理服务器的一个典型应用就是为处于防火墙后的内部客户端提供访问外部Internet网，比如校园网用户通过代理访问国外网站，公司内网用户通过公司的统一代理访问外部Internet网站等。转发代理服务器也能够使用缓存来缓解原始服务器负载，提供响应速度。 2）反向代理服务器而反向代理服务器则相反，在客户端来看它就像一个普通的Web服务器。客户端不要做任何特殊的配置。客户端发送普通的请求来获取反向代理所属空间的内容。反向代理决定将这些请求发往何处，然后就好像它本身就是原始服务器一样将请求内容返回。 反向代理服务器的一个典型应用就是为处于防火墙后的服务器提供外部Internet用户的访问。反向代理能够用于在多个后端服务器提供负载均衡，或者为较慢的后端服务器提供缓存。此外，反向代理还能够简单地将多个服务器映射到同一个URL空间。 当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。 我的理解A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器3）NginxNginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。 Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。","raw":"---\ntitle: 代理服务器、反向代理服务器以及Nginx\ndate: 2017-09-21\ncategories: First\nauthor: 杨亨\ncover_picture: /images/nginx.jpg\ntags:\n    - 技术\n    - blog\n---\n### 最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别 ###\n### 代理服务器通常分为两种 \n    转发代理(forward proxy)服务器和反向代理(reverse proxy)服务器\n  #### 1） 转发代理服务器 ####\n转发代理服务器平常简称为代理服务器\n\n普通的转发代理服务器是客户端与原始服务器之间的一个中间服务器。\n\n为了从原始服务器获取内容，客户端发送请求到代理服务器，然后代理服务器从原始服务器中获取内容再返回给客户端。客户端必须专门地配置转发代理来访问其他站点，如在浏览器中配置代理服务器地址及端口号等。\n\n转发代理服务器的一个典型应用就是为处于防火墙后的内部客户端提供访问外部Internet网，比如校园网用户通过代理访问国外网站，公司内网用户通过公司的统一代理访问外部Internet网站等。转发代理服务器也能够使用缓存来缓解原始服务器负载，提供响应速度。\n\n![](https://i.imgur.com/pIFsOPL.jpg)\n\n#### 2）反向代理服务器 #### \n\n而反向代理服务器则相反，在客户端来看它就像一个普通的Web服务器。客户端不要做任何特殊的配置。客户端发送普通的请求来获取反向代理所属空间的内容。反向代理决定将这些请求发往何处，然后就好像它本身就是原始服务器一样将请求内容返回。\n\n反向代理服务器的一个典型应用就是为处于防火墙后的服务器提供外部Internet用户的访问。反向代理能够用于在多个后端服务器提供负载均衡，或者为较慢的后端服务器提供缓存。此外，反向代理还能够简单地将多个服务器映射到同一个URL空间。\n\n当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。**因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。**\n\n![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=81e7da92b7003af359b7d4325443ad39/bba1cd11728b47100e26c757c2cec3fdfc03231b.jpg)\n\n\n#### 我的理解 ####\n####  A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器 ####\n#### A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器 ####\n\n\n#### 3）Nginx  ####\n\nNginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。\nNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\n\n#### Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性: ####\n\n**作为 Web 服务器：**相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.\n**\n作为负载均衡服务器：**Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。\n\n**作为邮件代理服务器:** Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。\n\nNginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。","content":"<h3 id=\"最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别\"><a href=\"#最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别\" class=\"headerlink\" title=\"最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别\"></a>最近的项目中用到了nginx访问外部服务器，那么nginx究竟有什么用，想要了解nginx，就要了解反向代理，那么，什么是反向代理，这核普通的代理服务器有什么区别</h3><h3 id=\"代理服务器通常分为两种\"><a href=\"#代理服务器通常分为两种\" class=\"headerlink\" title=\"代理服务器通常分为两种\"></a>代理服务器通常分为两种</h3><pre><code>转发代理(forward proxy)服务器和反向代理(reverse proxy)服务器\n</code></pre><h4 id=\"1）-转发代理服务器\"><a href=\"#1）-转发代理服务器\" class=\"headerlink\" title=\"1） 转发代理服务器\"></a>1） 转发代理服务器</h4><p>转发代理服务器平常简称为代理服务器</p>\n<p>普通的转发代理服务器是客户端与原始服务器之间的一个中间服务器。</p>\n<p>为了从原始服务器获取内容，客户端发送请求到代理服务器，然后代理服务器从原始服务器中获取内容再返回给客户端。客户端必须专门地配置转发代理来访问其他站点，如在浏览器中配置代理服务器地址及端口号等。</p>\n<p>转发代理服务器的一个典型应用就是为处于防火墙后的内部客户端提供访问外部Internet网，比如校园网用户通过代理访问国外网站，公司内网用户通过公司的统一代理访问外部Internet网站等。转发代理服务器也能够使用缓存来缓解原始服务器负载，提供响应速度。</p>\n<p><img src=\"https://i.imgur.com/pIFsOPL.jpg\" alt=\"\"></p>\n<h4 id=\"2）反向代理服务器\"><a href=\"#2）反向代理服务器\" class=\"headerlink\" title=\"2）反向代理服务器\"></a>2）反向代理服务器</h4><p>而反向代理服务器则相反，在客户端来看它就像一个普通的Web服务器。客户端不要做任何特殊的配置。客户端发送普通的请求来获取反向代理所属空间的内容。反向代理决定将这些请求发往何处，然后就好像它本身就是原始服务器一样将请求内容返回。</p>\n<p>反向代理服务器的一个典型应用就是为处于防火墙后的服务器提供外部Internet用户的访问。反向代理能够用于在多个后端服务器提供负载均衡，或者为较慢的后端服务器提供缓存。此外，反向代理还能够简单地将多个服务器映射到同一个URL空间。</p>\n<p>当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。<strong>因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</strong></p>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=81e7da92b7003af359b7d4325443ad39/bba1cd11728b47100e26c757c2cec3fdfc03231b.jpg\" alt=\"\"></p>\n<h4 id=\"我的理解\"><a href=\"#我的理解\" class=\"headerlink\" title=\"我的理解\"></a>我的理解</h4><h4 id=\"A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器\"><a href=\"#A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器\" class=\"headerlink\" title=\"A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器\"></a>A要向C借钱，但A联系不上C，就给B打电话找到C借钱，B就是代理服务器</h4><h4 id=\"A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器\"><a href=\"#A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器\" class=\"headerlink\" title=\"A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器\"></a>A要向C借钱，然后B知道后问C要上钱，A直接问B要钱就行，B就是反向代理服务器</h4><h4 id=\"3）Nginx\"><a href=\"#3）Nginx\" class=\"headerlink\" title=\"3）Nginx\"></a>3）Nginx</h4><p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。<br>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<br>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>\n<h4 id=\"Nginx-是一个高性能的-Web-和反向代理服务器-它具有有很多非常优越的特性\"><a href=\"#Nginx-是一个高性能的-Web-和反向代理服务器-它具有有很多非常优越的特性\" class=\"headerlink\" title=\"Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:\"></a>Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:</h4><p><strong>作为 Web 服务器：</strong>相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.<br><strong><br>作为负载均衡服务器：</strong>Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。</p>\n<p><strong>作为邮件代理服务器:</strong> Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。</p>\n<p>Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。</p>\n","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"如何使用vue.js控制列表数据的单条详细信息显示与隐藏","slug":"vuedivshow","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2017/09/05/vuedivshow/","link":"","permalink":"http://yoursite.com/2017/09/05/vuedivshow/","excerpt":"如何使用vue.js控制列表数据的单条详细信息显示与隐藏","text":"如何使用vue.js控制列表数据的单条详细信息显示与隐藏 如何使用vue.js控制列表数据的单条详细信息显示与隐藏该效果是指界面遍历显示了列表中的多个数据,如图所示 当点击第一条数据的时候，显示其详细信息，如图所示 当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示 那么该如何达到这个效果使用vue.js的话我们首先想到的是使用v-show指令控制元素的显示或隐藏那么我们设置一个全局变量planDetailisShow: false,来控制详细设计的div，然后点击一条数据的时候回出现点击一条数据，所有数据的详细信息都会显示出来 ###怎样控制v-show中的布尔值只控制该条数据呢？ 1.首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏并设初值为false,即不显示XdLoanPayplanQuery xdLoanPayplanQuery = new XdLoanPayplanQuery(); xdLoanPayplanQuery.setLoanbillCode(xdLoanbill.getBillCode()); List&lt;XdLoanPayplan&gt; xdLoanPayplanList = xdLoanPayplanService.getXdLoanPayplanAll(xdLoanPayplanQuery); for(int i=0;i&lt;xdLoanPayplanList.size();i++){ xdLoanPayplanList.get(i).setIsShow(false); } 2.接着前端的详细div设置v-show&lt;div class=&quot;planDetail-row&quot; v-show=&quot;plan.isShow&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;div class=&quot;info-wrap&quot; style=&quot;padding-bottom: 1.5px;height: 30px;&quot;&gt; &lt;el-col :span=&quot;9&quot;&gt;&lt;span class=&quot;detail-title&quot;&gt;咨询费率&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;1&quot; style=&quot;padding-right:10px;&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;5&quot;&gt;&lt;span class=&quot;detail-info&quot;&gt;{{plan.period}}&lt;/span&gt;&lt;/el-col&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;div class=&quot;info-wrap&quot; style=&quot;padding-bottom: 1.5px;height: 30px;&quot;&gt; &lt;el-col :span=&quot;7&quot; &gt;&lt;span class=&quot;detail-title&quot;&gt;应收本金&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;1&quot; &gt;&lt;span&gt;:&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot; &gt;&lt;span class=&quot;detail-info&quot;&gt;{{plan.payPrincipal}}&lt;/span&gt;&lt;/el-col&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; 注：plan为&lt;template v-for=&quot;(plan,index) in loanPayplan&quot;&gt;中的plan 3.编写数据的click事件planDetailChange(index,row){ debugger; if(row.isShow == true){ row.isShow = false; }else{ for (var value of this.loanPayplan) { value.isShow =false; } row.isShow = true; } }, 通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果","raw":"---\ntitle: 如何使用vue.js控制列表数据的单条详细信息显示与隐藏\ndate: 2017-09-05\ncategories: First\nauthor: 杨亨\ncover_picture: /images/plan2.png\ntags:\n    - 技术\n    - blog\n---\n如何使用vue.js控制列表数据的单条详细信息显示与隐藏\n<!-- more -->\n---\n# 如何使用vue.js控制列表数据的单条详细信息显示与隐藏\n#### 该效果是指界面遍历显示了列表中的多个数据,如图所示\n![](/images/plan1.png)\n#### 当点击第一条数据的时候，显示其详细信息，如图所示\n![](/images/plan2.png)\n#### 当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示\n![](/images/plan3.png)\n### 那么该如何达到这个效果\n使用vue.js的话我们首先想到的是使用v-show指令控制元素的显示或隐藏\n那么我们设置一个全局变量`planDetailisShow: false,`来控制详细设计的div，然后点击一条数据的时候回出现点击一条数据，**所有数据的详细信息都会显示出来**\n###怎样控制v-show中的布尔值只控制该条数据呢？\n#### 1.首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏\n#### 并设初值为false,即不显示\n\t\t\n     XdLoanPayplanQuery xdLoanPayplanQuery = new XdLoanPayplanQuery();\n            xdLoanPayplanQuery.setLoanbillCode(xdLoanbill.getBillCode());\n            List<XdLoanPayplan> xdLoanPayplanList = xdLoanPayplanService.getXdLoanPayplanAll(xdLoanPayplanQuery);\n            for(int i=0;i<xdLoanPayplanList.size();i++){\n            \txdLoanPayplanList.get(i).setIsShow(false);\n    \t\t}\n#### 2.接着前端的详细div设置v-show\n    <div class=\"planDetail-row\" v-show=\"plan.isShow\">\n    \t\t\t\t<el-row>\n    \t\t\t\t\t<el-col :span=\"12\">\n    \t\t\t\t\t\t<div class=\"info-wrap\" style=\"padding-bottom: 1.5px;height: 30px;\">\n    \t\t\t\t\t\t\t<el-col :span=\"9\"><span class=\"detail-title\">咨询费率</span></el-col>\n    \t\t\t\t\t\t\t<el-col :span=\"1\" style=\"padding-right:10px;\"><span>:</span></el-col>\n    \t\t\t\t\t\t\t<el-col :span=\"5\"><span class=\"detail-info\">{{plan.period}}</span></el-col>\n    \t\t\t\t\t\t</div>\n    \t\t\t\t\t</el-col>\n    \t\t\t\t\t<el-col :span=\"12\">\n    \t\t\t\t\t\t<div class=\"info-wrap\" style=\"padding-bottom: 1.5px;height: 30px;\">\n    \t\t\t\t\t\t\t<el-col :span=\"7\" ><span class=\"detail-title\">应收本金</span></el-col>\n    \t\t\t\t\t\t\t<el-col :span=\"1\" ><span>:</span></el-col>\n    \t\t\t\t\t\t\t<el-col :span=\"6\" ><span class=\"detail-info\">{{plan.payPrincipal}}</span></el-col>\n    \t\t\t\t\t\t</div>\n    \t\t\t\t\t</el-col>\n    \t\t\t\t</el-row>\n注：plan为`<template v-for=\"(plan,index) in loanPayplan\">`中的plan\n#### 3.编写数据的click事件\n    planDetailChange(index,row){\n    \t\t\t\tdebugger;\n    \t\t\t\tif(row.isShow == true){\n    \t\t\t\t\trow.isShow = false;\n    \t\t\t\t}else{\n    \t\t\t\tfor (var value of this.loanPayplan) {\n      \t\t\t\tvalue.isShow =false;\n    \t\t\t\t}\n    \t\t\t\trow.isShow = true;\n    \t\t\t\t}\n    \t\t\t},\n### 通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果","content":"<p>如何使用vue.js控制列表数据的单条详细信息显示与隐藏</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h1 id=\"如何使用vue-js控制列表数据的单条详细信息显示与隐藏\"><a href=\"#如何使用vue-js控制列表数据的单条详细信息显示与隐藏\" class=\"headerlink\" title=\"如何使用vue.js控制列表数据的单条详细信息显示与隐藏\"></a>如何使用vue.js控制列表数据的单条详细信息显示与隐藏</h1><h4 id=\"该效果是指界面遍历显示了列表中的多个数据-如图所示\"><a href=\"#该效果是指界面遍历显示了列表中的多个数据-如图所示\" class=\"headerlink\" title=\"该效果是指界面遍历显示了列表中的多个数据,如图所示\"></a>该效果是指界面遍历显示了列表中的多个数据,如图所示</h4><p><img src=\"/images/plan1.png\" alt=\"\"></p>\n<h4 id=\"当点击第一条数据的时候，显示其详细信息，如图所示\"><a href=\"#当点击第一条数据的时候，显示其详细信息，如图所示\" class=\"headerlink\" title=\"当点击第一条数据的时候，显示其详细信息，如图所示\"></a>当点击第一条数据的时候，显示其详细信息，如图所示</h4><p><img src=\"/images/plan2.png\" alt=\"\"></p>\n<h4 id=\"当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示\"><a href=\"#当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示\" class=\"headerlink\" title=\"当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示\"></a>当点击第二条数据的时候，第一条数据的详细信息隐藏，第二条数据的详细信息展开显示，如图所示</h4><p><img src=\"/images/plan3.png\" alt=\"\"></p>\n<h3 id=\"那么该如何达到这个效果\"><a href=\"#那么该如何达到这个效果\" class=\"headerlink\" title=\"那么该如何达到这个效果\"></a>那么该如何达到这个效果</h3><p>使用vue.js的话我们首先想到的是使用v-show指令控制元素的显示或隐藏<br>那么我们设置一个全局变量<code>planDetailisShow: false,</code>来控制详细设计的div，然后点击一条数据的时候回出现点击一条数据，<strong>所有数据的详细信息都会显示出来</strong></p>\n<p>###怎样控制v-show中的布尔值只控制该条数据呢？</p>\n<h4 id=\"1-首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏\"><a href=\"#1-首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏\" class=\"headerlink\" title=\"1.首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏\"></a>1.首先我们先在后台中的bean中加入一个布尔值字段负责控制该数据的显示隐藏</h4><h4 id=\"并设初值为false-即不显示\"><a href=\"#并设初值为false-即不显示\" class=\"headerlink\" title=\"并设初值为false,即不显示\"></a>并设初值为false,即不显示</h4><pre><code>XdLoanPayplanQuery xdLoanPayplanQuery = new XdLoanPayplanQuery();\n       xdLoanPayplanQuery.setLoanbillCode(xdLoanbill.getBillCode());\n       List&lt;XdLoanPayplan&gt; xdLoanPayplanList = xdLoanPayplanService.getXdLoanPayplanAll(xdLoanPayplanQuery);\n       for(int i=0;i&lt;xdLoanPayplanList.size();i++){\n           xdLoanPayplanList.get(i).setIsShow(false);\n       }\n</code></pre><h4 id=\"2-接着前端的详细div设置v-show\"><a href=\"#2-接着前端的详细div设置v-show\" class=\"headerlink\" title=\"2.接着前端的详细div设置v-show\"></a>2.接着前端的详细div设置v-show</h4><pre><code>&lt;div class=&quot;planDetail-row&quot; v-show=&quot;plan.isShow&quot;&gt;\n                &lt;el-row&gt;\n                    &lt;el-col :span=&quot;12&quot;&gt;\n                        &lt;div class=&quot;info-wrap&quot; style=&quot;padding-bottom: 1.5px;height: 30px;&quot;&gt;\n                            &lt;el-col :span=&quot;9&quot;&gt;&lt;span class=&quot;detail-title&quot;&gt;咨询费率&lt;/span&gt;&lt;/el-col&gt;\n                            &lt;el-col :span=&quot;1&quot; style=&quot;padding-right:10px;&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/el-col&gt;\n                            &lt;el-col :span=&quot;5&quot;&gt;&lt;span class=&quot;detail-info&quot;&gt;{{plan.period}}&lt;/span&gt;&lt;/el-col&gt;\n                        &lt;/div&gt;\n                    &lt;/el-col&gt;\n                    &lt;el-col :span=&quot;12&quot;&gt;\n                        &lt;div class=&quot;info-wrap&quot; style=&quot;padding-bottom: 1.5px;height: 30px;&quot;&gt;\n                            &lt;el-col :span=&quot;7&quot; &gt;&lt;span class=&quot;detail-title&quot;&gt;应收本金&lt;/span&gt;&lt;/el-col&gt;\n                            &lt;el-col :span=&quot;1&quot; &gt;&lt;span&gt;:&lt;/span&gt;&lt;/el-col&gt;\n                            &lt;el-col :span=&quot;6&quot; &gt;&lt;span class=&quot;detail-info&quot;&gt;{{plan.payPrincipal}}&lt;/span&gt;&lt;/el-col&gt;\n                        &lt;/div&gt;\n                    &lt;/el-col&gt;\n                &lt;/el-row&gt;\n</code></pre><p>注：plan为<code>&lt;template v-for=&quot;(plan,index) in loanPayplan&quot;&gt;</code>中的plan</p>\n<h4 id=\"3-编写数据的click事件\"><a href=\"#3-编写数据的click事件\" class=\"headerlink\" title=\"3.编写数据的click事件\"></a>3.编写数据的click事件</h4><pre><code>planDetailChange(index,row){\n                debugger;\n                if(row.isShow == true){\n                    row.isShow = false;\n                }else{\n                for (var value of this.loanPayplan) {\n                  value.isShow =false;\n                }\n                row.isShow = true;\n                }\n            },\n</code></pre><h3 id=\"通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果\"><a href=\"#通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果\" class=\"headerlink\" title=\"通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果\"></a>通过在bean中增加字段的方式，即可给不同数据添加控制显示的布尔值，达到预期的效果</h3>","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"使用Hexo+GitHub搭建个人博客","slug":"myblogbuild","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2017/08/25/myblogbuild/","link":"","permalink":"http://yoursite.com/2017/08/25/myblogbuild/","excerpt":"使用hexo和github搭建个人博客","text":"使用hexo和github搭建个人博客 一、前言之前一直都是使用Jekyll+GitHub搭建个人博客，但由于Jekyll是基于Ruby实现，搭建本地服务比较麻烦，我个人又对Ruby不熟悉，因此就转用Hexo搭建博客了。Hexo是基于NodeJS实现的，相对于Jekyll，实现Hexo的调试环境就简单许多。 二、配置环境和创建项目1.安装Hexo$ sudo npm install -g hexo 安装完后就可以初始化一个项目 2.初始化项目$ sudo hexo init projectname 目录结构：. ├── node_modules // 依赖 ├── scaffolds // 脚手架、骨架 ├── source // 资源文件夹 │ └── _posts // 新建的文章保存在这里 ├── themes // 主题文件夹 │ └── landscape // 默认主题 ├── _config.yml // 全局配置文件 ├── package.json // 项目的参数和所依赖插件 _config.yml全局配置文件；网站的名称、副标题、描述、作者、语言、主题、时间格式、URL、端口、代码高亮、部署等等参数 3.生成HTML静态页$ hexo generate 或者1$ hexo g 4.启动服务预览1$ hexo server 或者1$ hexo s 启动服务后，在浏览器输入 http://localhost:4000/ 即可访问。默认情况下，Hexo服务启动的端口为4000，若端口被占用或想使用其他端口启动，则运行命令：1$ hexo server -p 端口 如果不想每次启动时都输入端口，可以全局配置文件 _config.yml 中配置默认端口1修改 _config.yml 配置文件时，冒号 : 和右边的直之间要有一个空格 12server: port: 8800 # 配置默认端口 上图为浏览结果，我个人觉得默认主题不好看；因此，我找了另一个主题。 三、修改主题我的个人博客使用了 miho 主题，因此，我们也做这个主题做案例吧。 1.主题简介miho 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 2.安装2.1安装主题$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho miho主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/mihogit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。Json-content生成站点文章静态数据，用于站内搜索。1npm install hexo-generator-json-content --save ###3. 站点配置站点配置文件1_config.yml 在hexo根目录下。 3.1 启用主题`theme: miho` ####3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看 title: MinHow&apos;s Blog subtitle: 网站副标题 description: 专注 WEB 开发的技术博客 author: MinHow language: 网站使用的语言 timezone: 网站时区 ####3.3 jsonContent配置详细的配置请查看hexo-generator-json-content jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 4.主题配置编辑主题配置文件，themes/miho/_config.yml。 ####4.1 属性下面将介绍几个比较重要的配置。 # hexo-theme-miho # https://github.com/wongminho/hexo-theme-miho # Favicon of your site | 网站icon favicon: /favicon.ico # Header # Keywords of your site | 网站关键字 keywords: MinHow,MinHow&apos;s Blog # Head headline | 头部标题 header_title: MinHow&apos;s Blog # Head description | 头部描述 header_description: 一个专注 WEB 开发的技术博客 # Link to your logo | logo地址 logo: images/logo.png # Link to your banner_img | 首页banner图地址 banner_img: images/banner.jpg # Head navigation, use to display social information | 头部导航，用来展示社交信息 # name: Font Awesome icon | Font Awesome 图标 # title: Home Icon title | 图标标题 # url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径 # target: true Whether to jump out | 是否跳出 header_nav: home: title: Home url: //minhow.com target: false github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin: # Content # Excerpt length | 摘录长度 excerpt_length: 190 # Excerpt link | 摘录链接 excerpt_link: more&gt;&gt; # New window open link | 新窗口打开文章 open_new_link: false # Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150 cover_picture: images/banner.jpg # Open background particles | 开启背景粒子 open_bg_particle: true # Open animation in homepage and head | 开启主页及头部动画 open_animation: true # Article # Open toc | 是否开启toc toc: true # Style customization | 样式定制 style: # Main color tone | 主色调 main_color: &apos;#0cc&apos; # Comments | 评论 # 畅言 changyan_appid: false changyan_conf: false # disqus disqus: false # Analytics | 分析 # 站长分析，输入站点id cnzz_analytics: false # 百度分析，输入key值 baidu_analytics: false # google analytics | google分析 google_analytics: false # Footer # Access statistics | “不蒜子”访问量统计 access_counter: on: true site_uv: 总访客数： site_pv: 总访问量： # Copyright Information | 版权信息 copyright: 2017 MinHow 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。 cover_picture: images/banner.jpg ####4.3 开启背景粒子是否开启背景粒子。 open_bg_particle: true ####4.4 开启主页及头部动画是否开启主页及头部动画。 open_animation: true ####4.5 评论支持畅言、disqus。 # 畅言 changyan_appid: false changyan_conf: false # disqus disqus: false ####4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。 # 站长分析，输入站点id cnzz_analytics: false # 百度分析，输入key值 baidu_analytics: false # google分析 google_analytics: false ####4.7 文章基本配置title: Hello World date: 2017-06-18 categories: First author: MinHow tags: - First - Second --- MinHow-这是摘要 &lt;!-- more --&gt; cover_picture: /images/banner.jpg --- 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要；cover_picture文章封面图，不填默认显示_config.yml配置的图片。 四、配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 $ cd ~/. ssh 如果提示：No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 .ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示 s Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi yangheng! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！此时你还需要配置： $ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称 $ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 五、上传到github hexo d如果你一切都配置好了，发布上传很容易，一句 hexo d 就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分：正确写法： deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 六、写博客定位到我们的hexo根目录，执行命令： hexo new &apos;my-first-blog&apos; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 七、最终效果可以访问我的git博客来查看效果： https://yang00yang.github.io/","raw":"---\ntitle: 使用Hexo+GitHub搭建个人博客\ndate: 2017-08-25\ncategories: First\nauthor: 杨亨\ncover_picture: /images/sven.jpg\ntags:\n    - 技术\n    - blog\n---\n使用hexo和github搭建个人博客\n<!-- more -->\n---\n## 一、前言\n之前一直都是使用Jekyll+GitHub搭建个人博客，但由于Jekyll是基于Ruby实现，搭建本地服务比较麻烦，我个人又对Ruby不熟悉，因此就转用Hexo搭建博客了。Hexo是基于NodeJS实现的，相对于Jekyll，实现Hexo的调试环境就简单许多。\n## 二、配置环境和创建项目\n### 1.安装Hexo\n    $ sudo npm install -g hexo\n安装完后就可以初始化一个项目\n### 2.初始化项目\n    $ sudo hexo init projectname\n#### 目录结构：\n    .\n    ├── node_modules             // 依赖\n    ├── scaffolds                // 脚手架、骨架\n    ├── source                   // 资源文件夹\n    │   └── _posts               // 新建的文章保存在这里\n    ├── themes                   // 主题文件夹\n    │   └── landscape            // 默认主题\n    ├── _config.yml              // 全局配置文件\n    ├── package.json             // 项目的参数和所依赖插件\n**_config.yml**\n全局配置文件；网站的名称、副标题、描述、作者、语言、主题、时间格式、URL、端口、代码高亮、部署等等参数\n### 3.生成HTML静态页\n    $ hexo generate\n或者\n```shell\n$ hexo g\n```\n### 4.启动服务预览\n```shell\n$ hexo server\n```\n或者\n```shell\n$ hexo s\n```\n启动服务后，在浏览器输入 http://localhost:4000/ 即可访问。默认情况下，Hexo服务启动的端口为4000，若端口被占用或想使用其他端口启动，则运行命令：\n```shell\n$ hexo server -p 端口\n```\n如果不想每次启动时都输入端口，可以全局配置文件 _config.yml 中配置默认端口\n```shell\n修改 _config.yml 配置文件时，冒号 : 和右边的直之间要有一个空格\n```\n```shell\nserver:\n  port: 8800    # 配置默认端口\n```\n![](http://upload-images.jianshu.io/upload_images/4290261-3373cb08dd5ad235.png?imageMogr2/auto-orient/strip)\n上图为浏览结果，我个人觉得默认主题不好看；因此，我找了另一个主题。\n## 三、修改主题\n我的个人博客使用了 miho  主题，因此，我们也做这个主题做案例吧。\n### 1.主题简介\nmiho 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。\n### 2.安装\n#### 2.1安装主题\n    \t\n    $ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho\n    \nmiho主题需要Hexo 3.0或以上版本，请先升级。\n#### 2.2 更新\n```shell\ncd themes/miho\ngit pull\n```\n#### 2.3 依赖安装\n如下依赖如果已经安装，请看配置介绍。\nJson-content\n生成站点文章静态数据，用于站内搜索。\n```shell\nnpm install hexo-generator-json-content --save\n```\n###3. 站点配置\n站点配置文件\n```\n_config.yml\n```\n在hexo根目录下。\n#### 3.1 启用主题\n    \t\n    `theme: miho`\n    \n####3.2 网站基本配置\n以下配置是站点的全局配置，更多配置，[请查看](https://hexo.io/zh-cn/docs/configuration.html \"请查看\")\n    \t\n    title: MinHow's Blog\n    subtitle: 网站副标题\n    description: 专注 WEB 开发的技术博客\n\tauthor: MinHow\n\tlanguage: 网站使用的语言\n\ttimezone: 网站时区\n    \n####3.3 jsonContent配置\n详细的配置请查看[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content \"hexo-generator-json-content\")\n\t\n\tjsonContent:\n      meta: false\n      pages: false\n      posts:\n        title: true\n        date: true\n        path: true\n        text: false\n        raw: false\n        content: false\n        slug: false\n        updated: false\n        comments: false\n        link: false\n        permalink: false\n        excerpt: false\n        categories: false\n        tags: false\n### 4.主题配置\n编辑主题配置文件，\n```\nthemes/miho/_config.yml\n```。\n####4.1 属性\n下面将介绍几个比较重要的配置。\n    # hexo-theme-miho\n    # https://github.com/wongminho/hexo-theme-miho\n    # Favicon of your site | 网站icon\n    favicon: /favicon.ico\n    # Header\n    # Keywords of your site | 网站关键字\n    keywords: MinHow,MinHow's Blog\n    # Head headline | 头部标题\n    header_title: MinHow's Blog\n    # Head description | 头部描述\n    header_description: 一个专注 WEB 开发的技术博客\n    # Link to your logo | logo地址\n    logo: images/logo.png\n    # Link to your banner_img | 首页banner图地址\n    banner_img: images/banner.jpg\n    # Head navigation, use to display social information | 头部导航，用来展示社交信息\n    #  name:                  Font Awesome icon | Font Awesome 图标\n    #    title: Home          Icon title | 图标标题\n    #    url: //minhow.com    Url, absolute or relative path | 链接，绝对或相对路径\n    #    target: true         Whether to jump out | 是否跳出\n    header_nav:\n      home:\n        title: Home\n        url: //minhow.com\n        target: false\n      github:\n        title: Github\n        url: //github.com/wongminho\n        target: true\n      weibo:\n        title: Weibo\n        url: //weibo.com/WongMinHo\n        target: true\n      twitter:\n        title: Twitter\n        url: //twitter.com/huangminhow\n        target: true\n      #qq:\n      #weixin:\n      #snapchat:\n      #telegram:\n      #mail:\n      #facebook:\n      #google:\n      #linkedin:\n    # Content\n    # Excerpt length | 摘录长度\n    excerpt_length: 190\n    # Excerpt link | 摘录链接\n    excerpt_link: more>>\n    # New window open link | 新窗口打开文章\n    open_new_link: false\n    # Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150\n    cover_picture: images/banner.jpg\n    # Open background particles | 开启背景粒子\n    open_bg_particle: true\n    # Open animation in homepage and head | 开启主页及头部动画\n    open_animation: true\n    # Article\n    # Open toc | 是否开启toc\n    toc: true\n    # Style customization | 样式定制\n    style:\n      # Main color tone | 主色调\n      main_color: '#0cc'\n    # Comments | 评论\n    # 畅言\n    changyan_appid: false\n    changyan_conf: false\n    # disqus\n    disqus: false\n    # Analytics | 分析\n    # 站长分析，输入站点id\n    cnzz_analytics: false\n    # 百度分析，输入key值\n    baidu_analytics: false\n    # google analytics | google分析\n    google_analytics: false\n    # Footer\n    # Access statistics | “不蒜子”访问量统计\n    access_counter:\n      on: true\n      site_uv: 总访客数：\n      site_pv: 总访问量：\n    # Copyright Information | 版权信息\n    copyright: 2017 MinHow\n#### 4.2 文章封面图\n\n文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。\n    \t\n    cover_picture: images/banner.jpg\n    \n####4.3 开启背景粒子\n是否开启背景粒子。\n\n    open_bg_particle: true\n\n####4.4 开启主页及头部动画\n是否开启主页及头部动画。\n\n    open_animation: true\n\n####4.5 评论\n支持畅言、disqus。\n    # 畅言\n    changyan_appid: false\n    changyan_conf: false\n    # disqus\n    disqus: false\n\t\n####4.6 数据统计\n支持站长、百度、google三种数据统计，正确填写配置信息即可。\n    \n    # 站长分析，输入站点id\n    cnzz_analytics: false\n    # 百度分析，输入key值\n    baidu_analytics: false\n    # google分析\n    google_analytics: false\n    \n####4.7 文章基本配置\n    ---\n    title: Hello World\n    date: 2017-06-18\n    categories: First\n    author: MinHow\n    tags:\n        - First\n        - Second\n    ---\n    MinHow-这是摘要\n    <!-- more -->\n    cover_picture: /images/banner.jpg\n    ---\n说明：\n\n需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要；\ncover_picture文章封面图，不填默认显示_config.yml配置的图片。\n## 四、配置SSH key\n为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n    \n    $ cd ~/. ssh\n如果提示：No such file or directory 说明你是第一次使用git。\n    \n    ssh-keygen -t rsa -C \"邮件地址\"\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到   .ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key：\n\n![](http://image.liuxianan.com/201608/20160818_143914_495_9084.png?_=5800863)\n将刚复制的内容粘贴到key那里，title随便填，保存。\n### 测试是否成功\n    $ ssh -T git@github.com # 注意邮箱地址不用改\n如果提示    ```s\nAre you sure you want to continue connecting (yes/no)?\n```，输入yes，然后会看到：\n    \n    Hi yangheng! You've successfully authenticated, but GitHub does not provide shell access.\n看到这个信息说明SSH已配置成功！\n此时你还需要配置：\n    \n    $ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称\n    $ git config --global user.email  \"xxx@qq.com\"// 填写你的github注册邮箱\n## 五、上传到github\n hexo d如果你一切都配置好了，发布上传很容易，一句 `hexo d` 就搞定，当然关键还是你要把所有东西配置好。\n\n首先，`ssh key`肯定要配置好。\n\n其次，配置`_config.yml`中有关deploy的部分：\n正确写法：\n\n    deploy:\n      type: git\n      repository: git@github.com:liuxianan/liuxianan.github.io.git\n      branch: master\n后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：\n\n    \n    Deployer not found: github 或者 Deployer not found: git\n\n原因是还需要安装一个插件：\n\n    npm install hexo-deployer-git --save\n其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).\n\n打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会：\n## 六、写博客\n定位到我们的hexo根目录，执行命令：\n\n    hexo new 'my-first-blog'\nhexo会帮我们在_posts下生成相关md文件：\n\n![](http://image.liuxianan.com/201608/20160823_183047_352_1475.png?_=5800863)\n\n\n我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：\n\n![](http://image.liuxianan.com/201608/20160823_183325_470_9306.png?_=5800863)\n\n## 七、最终效果\n\n可以访问我的git博客来查看效果： https://yang00yang.github.io/\n","content":"<p>使用hexo和github搭建个人博客</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>之前一直都是使用Jekyll+GitHub搭建个人博客，但由于Jekyll是基于Ruby实现，搭建本地服务比较麻烦，我个人又对Ruby不熟悉，因此就转用Hexo搭建博客了。Hexo是基于NodeJS实现的，相对于Jekyll，实现Hexo的调试环境就简单许多。</p>\n<h2 id=\"二、配置环境和创建项目\"><a href=\"#二、配置环境和创建项目\" class=\"headerlink\" title=\"二、配置环境和创建项目\"></a>二、配置环境和创建项目</h2><h3 id=\"1-安装Hexo\"><a href=\"#1-安装Hexo\" class=\"headerlink\" title=\"1.安装Hexo\"></a>1.安装Hexo</h3><pre><code>$ sudo npm install -g hexo\n</code></pre><p>安装完后就可以初始化一个项目</p>\n<h3 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h3><pre><code>$ sudo hexo init projectname\n</code></pre><h4 id=\"目录结构：\"><a href=\"#目录结构：\" class=\"headerlink\" title=\"目录结构：\"></a>目录结构：</h4><pre><code>.\n├── node_modules             // 依赖\n├── scaffolds                // 脚手架、骨架\n├── source                   // 资源文件夹\n│   └── _posts               // 新建的文章保存在这里\n├── themes                   // 主题文件夹\n│   └── landscape            // 默认主题\n├── _config.yml              // 全局配置文件\n├── package.json             // 项目的参数和所依赖插件\n</code></pre><p><strong>_config.yml</strong><br>全局配置文件；网站的名称、副标题、描述、作者、语言、主题、时间格式、URL、端口、代码高亮、部署等等参数</p>\n<h3 id=\"3-生成HTML静态页\"><a href=\"#3-生成HTML静态页\" class=\"headerlink\" title=\"3.生成HTML静态页\"></a>3.生成HTML静态页</h3><pre><code>$ hexo generate\n</code></pre><p>或者<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> hexo g</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-启动服务预览\"><a href=\"#4-启动服务预览\" class=\"headerlink\" title=\"4.启动服务预览\"></a>4.启动服务预览</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> hexo server</div></pre></td></tr></table></figure>\n<p>或者<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> hexo s</div></pre></td></tr></table></figure></p>\n<p>启动服务后，在浏览器输入 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a> 即可访问。默认情况下，Hexo服务启动的端口为4000，若端口被占用或想使用其他端口启动，则运行命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> hexo server -p 端口</div></pre></td></tr></table></figure></p>\n<p>如果不想每次启动时都输入端口，可以全局配置文件 _config.yml 中配置默认端口<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">修改 _config.yml 配置文件时，冒号 : 和右边的直之间要有一个空格</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">server:</div><div class=\"line\">  port: 8800    # 配置默认端口</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4290261-3373cb08dd5ad235.png?imageMogr2/auto-orient/strip\" alt=\"\"><br>上图为浏览结果，我个人觉得默认主题不好看；因此，我找了另一个主题。</p>\n<h2 id=\"三、修改主题\"><a href=\"#三、修改主题\" class=\"headerlink\" title=\"三、修改主题\"></a>三、修改主题</h2><p>我的个人博客使用了 miho  主题，因此，我们也做这个主题做案例吧。</p>\n<h3 id=\"1-主题简介\"><a href=\"#1-主题简介\" class=\"headerlink\" title=\"1.主题简介\"></a>1.主题简介</h3><p>miho 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。</p>\n<h3 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h3><h4 id=\"2-1安装主题\"><a href=\"#2-1安装主题\" class=\"headerlink\" title=\"2.1安装主题\"></a>2.1安装主题</h4><pre><code>$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho\n</code></pre><p>miho主题需要Hexo 3.0或以上版本，请先升级。</p>\n<h4 id=\"2-2-更新\"><a href=\"#2-2-更新\" class=\"headerlink\" title=\"2.2 更新\"></a>2.2 更新</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd themes/miho</div><div class=\"line\">git pull</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-依赖安装\"><a href=\"#2-3-依赖安装\" class=\"headerlink\" title=\"2.3 依赖安装\"></a>2.3 依赖安装</h4><p>如下依赖如果已经安装，请看配置介绍。<br>Json-content<br>生成站点文章静态数据，用于站内搜索。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-generator-json-content --save</div></pre></td></tr></table></figure></p>\n<p>###3. 站点配置<br>站点配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">_config.yml</div></pre></td></tr></table></figure></p>\n<p>在hexo根目录下。</p>\n<h4 id=\"3-1-启用主题\"><a href=\"#3-1-启用主题\" class=\"headerlink\" title=\"3.1 启用主题\"></a>3.1 启用主题</h4><pre><code>`theme: miho`\n</code></pre><p>####3.2 网站基本配置<br>以下配置是站点的全局配置，更多配置，<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" title=\"请查看\" target=\"_blank\" rel=\"external\">请查看</a></p>\n<pre><code>title: MinHow&apos;s Blog\nsubtitle: 网站副标题\ndescription: 专注 WEB 开发的技术博客\nauthor: MinHow\nlanguage: 网站使用的语言\ntimezone: 网站时区\n</code></pre><p>####3.3 jsonContent配置<br>详细的配置请查看<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" title=\"hexo-generator-json-content\" target=\"_blank\" rel=\"external\">hexo-generator-json-content</a></p>\n<pre><code>jsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: false\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: false\n</code></pre><h3 id=\"4-主题配置\"><a href=\"#4-主题配置\" class=\"headerlink\" title=\"4.主题配置\"></a>4.主题配置</h3><p>编辑主题配置文件，<br><code>themes/miho/_config.yml</code>。</p>\n<p>####4.1 属性<br>下面将介绍几个比较重要的配置。</p>\n<pre><code># hexo-theme-miho\n# https://github.com/wongminho/hexo-theme-miho\n# Favicon of your site | 网站icon\nfavicon: /favicon.ico\n# Header\n# Keywords of your site | 网站关键字\nkeywords: MinHow,MinHow&apos;s Blog\n# Head headline | 头部标题\nheader_title: MinHow&apos;s Blog\n# Head description | 头部描述\nheader_description: 一个专注 WEB 开发的技术博客\n# Link to your logo | logo地址\nlogo: images/logo.png\n# Link to your banner_img | 首页banner图地址\nbanner_img: images/banner.jpg\n# Head navigation, use to display social information | 头部导航，用来展示社交信息\n#  name:                  Font Awesome icon | Font Awesome 图标\n#    title: Home          Icon title | 图标标题\n#    url: //minhow.com    Url, absolute or relative path | 链接，绝对或相对路径\n#    target: true         Whether to jump out | 是否跳出\nheader_nav:\n  home:\n    title: Home\n    url: //minhow.com\n    target: false\n  github:\n    title: Github\n    url: //github.com/wongminho\n    target: true\n  weibo:\n    title: Weibo\n    url: //weibo.com/WongMinHo\n    target: true\n  twitter:\n    title: Twitter\n    url: //twitter.com/huangminhow\n    target: true\n  #qq:\n  #weixin:\n  #snapchat:\n  #telegram:\n  #mail:\n  #facebook:\n  #google:\n  #linkedin:\n# Content\n# Excerpt length | 摘录长度\nexcerpt_length: 190\n# Excerpt link | 摘录链接\nexcerpt_link: more&gt;&gt;\n# New window open link | 新窗口打开文章\nopen_new_link: false\n# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150\ncover_picture: images/banner.jpg\n# Open background particles | 开启背景粒子\nopen_bg_particle: true\n# Open animation in homepage and head | 开启主页及头部动画\nopen_animation: true\n# Article\n# Open toc | 是否开启toc\ntoc: true\n# Style customization | 样式定制\nstyle:\n  # Main color tone | 主色调\n  main_color: &apos;#0cc&apos;\n# Comments | 评论\n# 畅言\nchangyan_appid: false\nchangyan_conf: false\n# disqus\ndisqus: false\n# Analytics | 分析\n# 站长分析，输入站点id\ncnzz_analytics: false\n# 百度分析，输入key值\nbaidu_analytics: false\n# google analytics | google分析\ngoogle_analytics: false\n# Footer\n# Access statistics | “不蒜子”访问量统计\naccess_counter:\n  on: true\n  site_uv: 总访客数：\n  site_pv: 总访问量：\n# Copyright Information | 版权信息\ncopyright: 2017 MinHow\n</code></pre><h4 id=\"4-2-文章封面图\"><a href=\"#4-2-文章封面图\" class=\"headerlink\" title=\"4.2 文章封面图\"></a>4.2 文章封面图</h4><p>文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。</p>\n<pre><code>cover_picture: images/banner.jpg\n</code></pre><p>####4.3 开启背景粒子<br>是否开启背景粒子。</p>\n<pre><code>open_bg_particle: true\n</code></pre><p>####4.4 开启主页及头部动画<br>是否开启主页及头部动画。</p>\n<pre><code>open_animation: true\n</code></pre><p>####4.5 评论<br>支持畅言、disqus。</p>\n<pre><code># 畅言\nchangyan_appid: false\nchangyan_conf: false\n# disqus\ndisqus: false\n</code></pre><p>####4.6 数据统计<br>支持站长、百度、google三种数据统计，正确填写配置信息即可。</p>\n<pre><code># 站长分析，输入站点id\ncnzz_analytics: false\n# 百度分析，输入key值\nbaidu_analytics: false\n# google分析\ngoogle_analytics: false\n</code></pre><h2 id=\"4-7-文章基本配置\"><a href=\"#4-7-文章基本配置\" class=\"headerlink\" title=\"####4.7 文章基本配置\"></a>####4.7 文章基本配置</h2><pre><code>title: Hello World\ndate: 2017-06-18\ncategories: First\nauthor: MinHow\ntags:\n    - First\n    - Second\n---\nMinHow-这是摘要\n&lt;!-- more --&gt;\ncover_picture: /images/banner.jpg\n---\n</code></pre><p>说明：</p>\n<p>需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要；<br>cover_picture文章封面图，不填默认显示_config.yml配置的图片。</p>\n<h2 id=\"四、配置SSH-key\"><a href=\"#四、配置SSH-key\" class=\"headerlink\" title=\"四、配置SSH key\"></a>四、配置SSH key</h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>\n<pre><code>$ cd ~/. ssh\n</code></pre><p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<pre><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;\n</code></pre><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到   .ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>\n<p><img src=\"http://image.liuxianan.com/201608/20160818_143914_495_9084.png?_=5800863\" alt=\"\"><br>将刚复制的内容粘贴到key那里，title随便填，保存。</p>\n<h3 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h3><pre><code>$ ssh -T git@github.com # 注意邮箱地址不用改\n</code></pre><p>如果提示    <code>s\nAre you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>\n<pre><code>Hi yangheng! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>看到这个信息说明SSH已配置成功！<br>此时你还需要配置：</p>\n<pre><code>$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称\n$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱\n</code></pre><h2 id=\"五、上传到github\"><a href=\"#五、上传到github\" class=\"headerlink\" title=\"五、上传到github\"></a>五、上传到github</h2><p> hexo d如果你一切都配置好了，发布上传很容易，一句 <code>hexo d</code> 就搞定，当然关键还是你要把所有东西配置好。</p>\n<p>首先，<code>ssh key</code>肯定要配置好。</p>\n<p>其次，配置<code>_config.yml</code>中有关deploy的部分：<br>正确写法：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master\n</code></pre><p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：</p>\n<pre><code>Deployer not found: github 或者 Deployer not found: git\n</code></pre><p>原因是还需要安装一个插件：</p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre><p>其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).</p>\n<p>打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会：</p>\n<h2 id=\"六、写博客\"><a href=\"#六、写博客\" class=\"headerlink\" title=\"六、写博客\"></a>六、写博客</h2><p>定位到我们的hexo根目录，执行命令：</p>\n<pre><code>hexo new &apos;my-first-blog&apos;\n</code></pre><p>hexo会帮我们在_posts下生成相关md文件：</p>\n<p><img src=\"http://image.liuxianan.com/201608/20160823_183047_352_1475.png?_=5800863\" alt=\"\"></p>\n<p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p>\n<p><img src=\"http://image.liuxianan.com/201608/20160823_183325_470_9306.png?_=5800863\" alt=\"\"></p>\n<h2 id=\"七、最终效果\"><a href=\"#七、最终效果\" class=\"headerlink\" title=\"七、最终效果\"></a>七、最终效果</h2><p>可以访问我的git博客来查看效果： <a href=\"https://yang00yang.github.io/\" target=\"_blank\" rel=\"external\">https://yang00yang.github.io/</a></p>\n","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"html页面","slug":"html页面","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/08/24/html页面/","link":"","permalink":"http://yoursite.com/2017/08/24/html页面/","excerpt":"","text":"我的第一个html页面点击预览","raw":"---\ntitle: html页面\ndate: 2017-08-24 17:14:20\ntags:\ncover_picture: /images/4.jpg\n---\n<html>\n<head>我的第一个html页面</head>\n<body><a href=\"https://yang00yang.github.io/gost/\">点击预览</body>\n</html>","content":"<html><br><head>我的第一个html页面</head><br><body><a href=\"https://yang00yang.github.io/gost/\" target=\"_blank\" rel=\"external\">点击预览</a></body><br></html>","categories":[],"tags":[]},{"title":"生日祝福","slug":"happy-birthday-to-you","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/08/24/happy-birthday-to-you/","link":"","permalink":"http://yoursite.com/2017/08/24/happy-birthday-to-you/","excerpt":"生日祝福","text":"生日祝福 祝蓉蓉小朋友生日快乐，永远开心漂亮，美美哒","raw":"---\ntitle: 生日祝福\ndate: 2017-08-24\ncategories: First\nauthor: 杨亨\ncover_picture: /images/bir.jpg\ntags:\n    - 祝福\n    - 关心\n---\n生日祝福\n<!-- more -->\n---\n祝蓉蓉小朋友生日快乐，永远开心漂亮，美美哒","content":"<p>生日祝福</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>祝蓉蓉小朋友生日快乐，永远开心漂亮，美美哒</p>\n","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"祝福","slug":"祝福","permalink":"http://yoursite.com/tags/祝福/"},{"name":"关心","slug":"关心","permalink":"http://yoursite.com/tags/关心/"}]}]}